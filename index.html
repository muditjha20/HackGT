<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bystander Coach VR Training</title>
    <!-- A-Frame 1.5.0 CDN -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- Web Speech API polyfill for better browser support -->
    <script src="https://cdn.jsdelivr.net/npm/speech-recognition-polyfill@0.1.4/dist/speech-recognition.min.js"></script>
    <style>
        /* 2D UI elements */
        #micPermission {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 10px 15px;
            background: rgba(0, 100, 200, 0.8);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
            font-size: 16px;
        }
        
        #micStatus {
            position: absolute;
            bottom: 60px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 14px;
        }
        
        /* Hidden canvas for PNG export */
        #exportCanvas {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Hidden canvas for exporting feedback card as PNG -->
    <canvas id="exportCanvas" width="800" height="600"></canvas>
    
    <!-- 2D UI elements -->
    <button id="micPermission">Enable Mic</button>
    <div id="micStatus">Mic: Disabled</div>
    
    <!-- A-Frame VR Scene -->
    <a-scene 
        background="color: #87CEEB" 
        webxr="requiredFeatures: local-floor; optionalFeatures: hand-tracking"
        xr-mode-ui="enabled: true">
        
        <!-- Camera Rig with controllers and gaze cursor -->
        <a-entity id="rig" movement-controls="speed: 0.5">
            <!-- Camera -->
            <a-camera id="camera" position="0 1.6 0">
                <!-- Gaze cursor for desktop/mobile fallback -->
                <a-cursor 
                    id="gazeCursor"
                    object3D="position: 0 0 -1"
                    raycaster="objects: .clickable"
                    animation__click="property: scale; startEvents: click; from: 0.1 0.1 0.1; to: 1 1 1; dur: 150">
                </a-cursor>
            </a-camera>
            
            <!-- Left controller -->
            <a-entity 
                laser-controls="hand: left" 
                raycaster="objects: .clickable"
                line="color: blue; opacity: 0.5">
                <!-- Hover indicator for left controller -->
                <a-entity 
                    class="hover-indicator"
                    geometry="primitive: sphere; radius: 0.01"
                    material="color: yellow; shader: flat"
                    visible="false">
                </a-entity>
            </a-entity>
            
            <!-- Right controller -->
            <a-entity 
                laser-controls="hand: right" 
                raycaster="objects: .clickable"
                line="color: blue; opacity: 0.5">
                <!-- Hover indicator for right controller -->
                <a-entity 
                    class="hover-indicator"
                    geometry="primitive: sphere; radius: 0.01"
                    material="color: yellow; shader: flat"
                    visible="false">
                </a-entity>
            </a-entity>
        </a-entity>
        
        <!-- Lighting -->
        <a-light type="ambient" color="#BBB" intensity="0.5"></a-light>
        <a-light type="directional" color="#FFF" intensity="0.8" position="-1 2 1"></a-light>
        
        <!-- Ground plane -->
        <a-plane 
            position="0 0 0" 
            rotation="-90 0 0" 
            width="20" 
            height="20" 
            color="#7BC8A4" 
            shadow="receive: true">
        </a-plane>
        
        <!-- UI Panel -->
        <a-entity id="uiPanel" position="0 1.2 -1.2">
            <!-- Panel background -->
            <a-plane 
                id="panelBg"
                width="1.8" 
                height="1.2" 
                color="#333" 
                opacity="0.9"
                position="0 0 0">
            </a-plane>
            
            <!-- Subtitle text -->
            <a-text 
                id="subtitle"
                value="Welcome to Bystander Coach" 
                width="1.6"
                align="center" 
                wrap-count="30"
                color="white" 
                position="0 0.4 0.01"
                font="https://cdn.aframe.io/fonts/mozillavr.fnt">
            </a-text>
            
            <!-- Response buttons (initially hidden) -->
            <a-entity id="responseButtons" visible="false">
                <!-- Button 1: Direct -->
                <a-box 
                    class="clickable response-btn"
                    data-choice="Direct"
                    width="1.2" 
                    height="0.2" 
                    depth="0.05"
                    color="#4CAF50"
                    position="0 0.1 0.01"
                    event-set__mouseenter="scale: 1.1 1.1 1.1"
                    event-set__mouseleave="scale: 1 1 1">
                    <a-text 
                        value="Direct" 
                        align="center" 
                        color="white" 
                        position="0 0 0.03"
                        width="1.2">
                    </a-text>
                </a-box>
                
                <!-- Button 2: Distract -->
                <a-box 
                    class="clickable response-btn"
                    data-choice="Distract"
                    width="1.2" 
                    height="0.2" 
                    depth="0.05"
                    color="#2196F3"
                    position="0 -0.1 0.01"
                    event-set__mouseenter="scale: 1.1 1.1 1.1"
                    event-set__mouseleave="scale: 1 1 1">
                    <a-text 
                        value="Distract" 
                        align="center" 
                        color="white" 
                        position="0 0 0.03"
                        width="1.2">
                    </a-text>
                </a-box>
                
                <!-- Button 3: Delegate -->
                <a-box 
                    class="clickable response-btn"
                    data-choice="Delegate"
                    width="1.2" 
                    height="0.2" 
                    depth="0.05"
                    color="#FF9800"
                    position="0 -0.3 0.01"
                    event-set__mouseenter="scale: 1.1 1.1 1.1"
                    event-set__mouseleave="scale: 1 1 1">
                    <a-text 
                        value="Delegate" 
                        align="center" 
                        color="white" 
                        position="0 0 0.03"
                        width="1.2">
                    </a-text>
                </a-box>
            </a-entity>
            
            <!-- Voice input button (initially hidden) -->
            <a-entity id="voiceInputSection" visible="false">
                <a-box 
                    id="speakNowBtn"
                    class="clickable"
                    width="1.2" 
                    height="0.2" 
                    depth="0.05"
                    color="#9C27B0"
                    position="0 -0.5 0.01"
                    event-set__mouseenter="scale: 1.1 1.1 1.1"
                    event-set__mouseleave="scale: 1 1 1">
                    <a-text 
                        value="Speak Now" 
                        align="center" 
                        color="white" 
                        position="0 0 0.03"
                        width="1.2">
                    </a-text>
                </a-box>
                
                <!-- Transcript display -->
                <a-text 
                    id="transcript"
                    value="" 
                    width="1.6"
                    align="center" 
                    wrap-count="30"
                    color="#FFEB3B" 
                    position="0 -0.7 0.01"
                    font="https://cdn.aframe.io/fonts/mozillavr.fnt">
                </a-text>
            </a-entity>
        </a-entity>
        
        <!-- Feedback Card (initially hidden) -->
        <a-entity id="feedbackCard" position="0 1.2 -0.8" scale="0 0 0" visible="false">
            <!-- Card background -->
            <a-plane 
                width="1.8" 
                height="1.8" 
                color="#222" 
                opacity="0.95"
                position="0 0 0">
            </a-plane>
            
            <!-- Card title -->
            <a-text 
                value="Feedback Card" 
                width="1.6"
                align="center" 
                color="white" 
                position="0 0.7 0.01"
                font="https://cdn.aframe.io/fonts/mozillavr.fnt">
            </a-text>
            
            <!-- Response summary -->
            <a-text 
                id="feedbackResponse"
                value="" 
                width="1.6"
                align="center" 
                wrap-count="30"
                color="#FF9800" 
                position="0 0.4 0.01"
                font="https://cdn.aframe.io/fonts/mozillavr.fnt">
            </a-text>
            
            <!-- Tone summary -->
            <a-text 
                id="feedbackTone"
                value="" 
                width="1.6"
                align="center" 
                wrap-count="30"
                color="#4CAF50" 
                position="0 0.2 0.01"
                font="https://cdn.aframe.io/fonts/mozillavr.fnt">
            </a-text>
            
            <!-- What went well -->
            <a-text 
                id="feedbackPositive"
                value="" 
                width="1.6"
                align="center" 
                wrap-count="30"
                color="#4CAF50" 
                position="0 0 0.01"
                font="https://cdn.aframe.io/fonts/mozillavr.fnt">
            </a-text>
            
            <!-- Suggestion -->
            <a-text 
                id="feedbackSuggestion"
                value="" 
                width="1.6"
                align="center" 
                wrap-count="30"
                color="#FF5722" 
                position="0 -0.2 0.01"
                font="https://cdn.aframe.io/fonts/mozillavr.fnt">
            </a-text>
            
            <!-- Better line suggestion -->
            <a-text 
                id="feedbackBetterLine"
                value="" 
                width="1.6"
                align="center" 
                wrap-count="30"
                color="#2196F3" 
                position="0 -0.4 0.01"
                font="https://cdn.aframe.io/fonts/mozillavr.fnt">
            </a-text>
            
            <!-- Save Card button -->
            <a-box 
                id="saveCardBtn"
                class="clickable"
                width="0.8" 
                height="0.15" 
                depth="0.05"
                color="#4CAF50"
                position="-0.4 -0.7 0.01"
                event-set__mouseenter="scale: 1.1 1.1 1.1"
                event-set__mouseleave="scale: 1 1 1">
                <a-text 
                    value="Save Card" 
                    align="center" 
                    color="white" 
                    position="0 0 0.03"
                    width="0.8">
                </a-text>
            </a-box>
            
            <!-- Replay button -->
            <a-box 
                id="replayBtn"
                class="clickable"
                width="0.8" 
                height="0.15" 
                depth="0.05"
                color="#2196F3"
                position="0.4 -0.7 0.01"
                event-set__mouseenter="scale: 1.1 1.1 1.1"
                event-set__mouseleave="scale: 1 1 1">
                <a-text 
                    value="Replay" 
                    align="center" 
                    color="white" 
                    position="0 0 0.03"
                    width="0.8">
                </a-text>
            </a-box>
        </a-entity>
        
        <!-- Demo object (spinning cube) -->
        <a-box 
            position="-2 1 -3" 
            rotation="0 45 0" 
            color="#4CC3D9"
            animation="property: rotation; to: 0 405 0; loop: true; dur: 5000">
        </a-box>
    </a-scene>

    <script>
        // SCENARIO DATA - Two-turn scenario for bus conflict
        const SCENARIO_BUS_V1 = {
            turn1: {
                npc_line: "A passenger is yelling at the bus driver over a fare dispute. What do you do?",
                good_keywords: ["calm", "help", "support", "understand", "okay", "please"],
                bad_keywords: ["shut up", "idiot", "stupid", "angry", "hate", "fight"],
                branches: {
                    STRONG: {
                        npc_react: "The passenger calms down slightly and explains their frustration more calmly.",
                        outcome: "cooling"
                    },
                    NEUTRAL: {
                        npc_react: "The passenger ignores you and continues arguing with the driver.",
                        outcome: "stall"
                    },
                    ESCALATE: {
                        npc_react: "The passenger turns their anger toward you, becoming more aggressive.",
                        outcome: "escalate"
                    }
                }
            },
            turn2: {
                npc_line: "The passenger is now directing their frustration at you. How do you respond?",
                good_keywords: ["space", "breathe", "cool", "safe", "respect", "listen"],
                bad_keywords: ["back off", "threaten", "yell", "attack", "police", "fight"],
                branches: {
                    STRONG: {
                        npc_react: "The passenger takes a step back and apologizes for their behavior.",
                        outcome: "cooling"
                    },
                    NEUTRAL: {
                        npc_react: "The passenger continues complaining but with less intensity.",
                        outcome: "stall"
                    },
                    ESCALATE: {
                        npc_react: "The situation escalates and other passengers get involved.",
                        outcome: "escalate"
                    }
                }
            }
        };

        // App state
        let appState = {
            currentTurn: 1,
            micEnabled: false,
            audioContext: null,
            analyser: null,
            mediaStream: null,
            recognition: null,
            isListening: false,
            gameData: {
                turn1: { response: "", tone: "", branch: "" },
                turn2: { response: "", tone: "", branch: "" }
            }
        };

        // DOM elements
        const micPermissionBtn = document.getElementById('micPermission');
        const micStatus = document.getElementById('micStatus');
        const subtitle = document.getElementById('subtitle');
        const responseButtons = document.getElementById('responseButtons');
        const voiceInputSection = document.getElementById('voiceInputSection');
        const speakNowBtn = document.getElementById('speakNowBtn');
        const transcript = document.getElementById('transcript');
        const feedbackCard = document.getElementById('feedbackCard');
        const feedbackResponse = document.getElementById('feedbackResponse');
        const feedbackTone = document.getElementById('feedbackTone');
        const feedbackPositive = document.getElementById('feedbackPositive');
        const feedbackSuggestion = document.getElementById('feedbackSuggestion');
        const feedbackBetterLine = document.getElementById('feedbackBetterLine');
        const saveCardBtn = document.getElementById('saveCardBtn');
        const replayBtn = document.getElementById('replayBtn');
        const exportCanvas = document.getElementById('exportCanvas');
        const ctx = exportCanvas.getContext('2d');

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            // Set up hover indicators for controllers
            setupHoverIndicators();
            
            // Start with the first turn
            startTurn(1);
            
            // Set up event listeners for 2D UI
            micPermissionBtn.addEventListener('click', requestMicrophonePermission);
            
            // Set up event listeners for VR elements
            setupVREventListeners();
        });

        // Set up hover indicators for controllers
        function setupHoverIndicators() {
            // Listen for controller intersections to show hover indicators
            const controllers = document.querySelectorAll('[laser-controls]');
            controllers.forEach(controller => {
                controller.addEventListener('raycaster-intersection', function(event) {
                    const hoverIndicator = controller.querySelector('.hover-indicator');
                    if (event.detail.els.length > 0) {
                        const intersection = event.detail.intersections[0];
                        hoverIndicator.object3D.position.copy(intersection.point);
                        hoverIndicator.setAttribute('visible', true);
                    }
                });
                
                controller.addEventListener('raycaster-intersection-cleared', function(event) {
                    const hoverIndicator = controller.querySelector('.hover-indicator');
                    hoverIndicator.setAttribute('visible', false);
                });
            });
        }

        // Set up event listeners for VR elements
        function setupVREventListeners() {
            // Response button clicks
            const responseBtns = document.querySelectorAll('.response-btn');
            responseBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    if (responseButtons.getAttribute('visible') === 'true') {
                        const choice = this.getAttribute('data-choice');
                        handleButtonResponse(choice);
                    }
                });
            });
            
            // Speak Now button click
            speakNowBtn.addEventListener('click', function() {
                if (voiceInputSection.getAttribute('visible') === 'true' && appState.micEnabled) {
                    startVoiceInput();
                }
            });
            
            // Save Card button click
            saveCardBtn.addEventListener('click', function() {
                exportFeedbackCard();
            });
            
            // Replay button click
            replayBtn.addEventListener('click', function() {
                resetGame();
            });
        }

        // Start a new turn
        function startTurn(turnNumber) {
            appState.currentTurn = turnNumber;
            const turnData = turnNumber === 1 ? SCENARIO_BUS_V1.turn1 : SCENARIO_BUS_V1.turn2;
            
            // Update subtitle with NPC line
            subtitle.setAttribute('value', turnData.npc_line);
            
            // Show response options
            responseButtons.setAttribute('visible', true);
            
            // Show voice input if mic is enabled
            voiceInputSection.setAttribute('visible', appState.micEnabled);
            
            // Reset transcript
            transcript.setAttribute('value', '');
            
            // Hide feedback card if it's visible
            feedbackCard.setAttribute('visible', false);
            feedbackCard.setAttribute('scale', '0 0 0');
        }

        // Handle button response
        function handleButtonResponse(choice) {
            // For button responses, use ASSERTIVE tone by default
            const tone = 'ASSERTIVE';
            const responseText = choice;
            
            // Evaluate the response
            evaluateResponse(responseText, tone, choice);
        }

        // Request microphone permission
        function requestMicrophonePermission() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(function(stream) {
                        appState.micEnabled = true;
                        appState.mediaStream = stream;
                        micStatus.textContent = 'Mic: Enabled';
                        micPermissionBtn.textContent = 'Mic Enabled';
                        micPermissionBtn.style.background = 'rgba(0, 200, 0, 0.8)';
                        
                        // Initialize audio context for tone analysis
                        initAudioContext(stream);
                        
                        // Initialize speech recognition if available
                        initSpeechRecognition();
                        
                        // Show voice input section
                        voiceInputSection.setAttribute('visible', true);
                    })
                    .catch(function(err) {
                        console.error('Error accessing microphone:', err);
                        micStatus.textContent = 'Mic: Access Denied';
                    });
            } else {
                micStatus.textContent = 'Mic: Not Supported';
            }
        }

        // Initialize audio context for tone analysis
        function initAudioContext(stream) {
            appState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            appState.analyser = appState.audioContext.createAnalyser();
            const source = appState.audioContext.createMediaStreamSource(stream);
            source.connect(appState.analyser);
            appState.analyser.fftSize = 256;
        }

        // Initialize speech recognition
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                appState.recognition = new SpeechRecognition();
                appState.recognition.continuous = false;
                appState.recognition.interimResults = false;
                appState.recognition.lang = 'en-US';
                
                appState.recognition.onresult = function(event) {
                    const transcriptText = event.results[0][0].transcript;
                    transcript.setAttribute('value', `You said: ${transcriptText}`);
                    
                    // Analyze tone from the recorded audio
                    analyzeTone(transcriptText);
                };
                
                appState.recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    transcript.setAttribute('value', 'Error: Could not understand speech');
                    // Fall back to button input
                    responseButtons.setAttribute('visible', true);
                };
                
                appState.recognition.onend = function() {
                    appState.isListening = false;
                    speakNowBtn.setAttribute('color', '#9C27B0');
                };
            } else {
                transcript.setAttribute('value', 'Speech recognition not supported');
            }
        }

        // Start voice input
        function startVoiceInput() {
            if (appState.isListening) return;
            
            appState.isListening = true;
            speakNowBtn.setAttribute('color', '#FF0000');
            transcript.setAttribute('value', 'Listening...');
            
            // Hide buttons during voice input
            responseButtons.setAttribute('visible', false);
            
            // Start speech recognition if available
            if (appState.recognition) {
                appState.recognition.start();
            } else {
                // Fallback: simulate speech input after a delay
                setTimeout(function() {
                    const sampleResponses = [
                        "Can everyone please stay calm?",
                        "Let's try to resolve this peacefully.",
                        "I think there's been a misunderstanding."
                    ];
                    const randomResponse = sampleResponses[Math.floor(Math.random() * sampleResponses.length)];
                    transcript.setAttribute('value', `You said: ${randomResponse}`);
                    analyzeTone(randomResponse);
                }, 2000);
            }
        }

        // Analyze tone from audio
        function analyzeTone(transcriptText) {
            if (!appState.analyser) {
                // If no analyser, use default tone
                evaluateResponse(transcriptText, 'ASSERTIVE', 'Voice');
                return;
            }
            
            // Capture audio data for 1 second
            const bufferLength = appState.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            // Collect data for 1 second (simplified - in reality would need to sample over time)
            setTimeout(function() {
                appState.analyser.getByteTimeDomainData(dataArray);
                
                // Calculate RMS (root mean square) for volume
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    // Convert to -1 to 1 range
                    const sample = (dataArray[i] - 128) / 128;
                    sum += sample * sample;
                }
                const rms = Math.sqrt(sum / bufferLength);
                
                // Calculate zero-crossing rate as a proxy for pace
                let zeroCrossings = 0;
                for (let i = 1; i < bufferLength; i++) {
                    if ((dataArray[i-1] < 128 && dataArray[i] >= 128) || 
                        (dataArray[i-1] >= 128 && dataArray[i] < 128)) {
                        zeroCrossings++;
                    }
                }
                const zeroCrossingRate = zeroCrossings / bufferLength;
                
                // Determine tone bucket
                let tone;
                if (rms < 0.25) {
                    tone = 'CALM';
                } else if (rms <= 0.6) {
                    tone = 'ASSERTIVE';
                } else {
                    tone = 'AGGRESSIVE';
                }
                
                // If high zero-crossing rate, consider it aggressive (fast speech)
                if (zeroCrossingRate > 0.3) {
                    tone = 'AGGRESSIVE';
                }
                
                // Evaluate the response with the detected tone
                evaluateResponse(transcriptText, tone, 'Voice');
            }, 1000);
        }

        // Evaluate the player's response
        function evaluateResponse(responseText, tone, inputMethod) {
            const turnData = appState.currentTurn === 1 ? SCENARIO_BUS_V1.turn1 : SCENARIO_BUS_V1.turn2;
            
            // Store game data
            appState.gameData[`turn${appState.currentTurn}`].response = responseText;
            appState.gameData[`turn${appState.currentTurn}`].tone = tone;
            
            // Keyword matching
            const lowerResponse = responseText.toLowerCase();
            let containsGoodKeyword = false;
            let containsBadKeyword = false;
            
            // Check for good keywords
            for (const keyword of turnData.good_keywords) {
                if (lowerResponse.includes(keyword.toLowerCase())) {
                    containsGoodKeyword = true;
                    break;
                }
            }
            
            // Check for bad keywords
            for (const keyword of turnData.bad_keywords) {
                if (lowerResponse.includes(keyword.toLowerCase())) {
                    containsBadKeyword = true;
                    break;
                }
            }
            
            // Determine branch based on rules
            let branch;
            if (containsGoodKeyword && tone !== 'AGGRESSIVE') {
                branch = 'STRONG';
            } else if (tone === 'AGGRESSIVE' || containsBadKeyword) {
                branch = 'ESCALATE';
            } else {
                branch = 'NEUTRAL';
            }
            
            // Store branch result
            appState.gameData[`turn${appState.currentTurn}`].branch = branch;
            
            // Show NPC reaction
            const npcReaction = turnData.branches[branch].npc_react;
            subtitle.setAttribute('value', npcReaction);
            
            // Hide response options
            responseButtons.setAttribute('visible', false);
            voiceInputSection.setAttribute('visible', false);
            
            // Play appropriate sound
            playToneSound(branch);
            
            // Move to next turn or show feedback
            setTimeout(function() {
                if (appState.currentTurn === 1) {
                    startTurn(2);
                } else {
                    showFeedbackCard();
                }
            }, 3000);
        }

        // Play a sound based on the branch outcome
        function playToneSound(branch) {
            if (!appState.audioContext) {
                // Create a temporary audio context if needed
                appState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const oscillator = appState.audioContext.createOscillator();
            const gainNode = appState.audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(appState.audioContext.destination);
            
            // Different tones for different outcomes
            if (branch === 'STRONG') {
                oscillator.frequency.setValueAtTime(523.25, appState.audioContext.currentTime); // C5 - positive
            } else if (branch === 'NEUTRAL') {
                oscillator.frequency.setValueAtTime(392.00, appState.audioContext.currentTime); // G4 - neutral
            } else {
                oscillator.frequency.setValueAtTime(311.13, appState.audioContext.currentTime); // D#4 - negative
            }
            
            gainNode.gain.setValueAtTime(0.1, appState.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, appState.audioContext.currentTime + 0.5);
            
            oscillator.start(appState.audioContext.currentTime);
            oscillator.stop(appState.audioContext.currentTime + 0.5);
        }

        // Show feedback card at the end of the scenario
        function showFeedbackCard() {
            // Determine overall outcome
            const turn1Outcome = SCENARIO_BUS_V1.turn1.branches[appState.gameData.turn1.branch].outcome;
            const turn2Outcome = SCENARIO_BUS_V1.turn2.branches[appState.gameData.turn2.branch].outcome;
            const isSuccess = turn1Outcome === 'cooling' || turn2Outcome === 'cooling';
            
            // Set feedback content based on outcome
            if (isSuccess) {
                feedbackResponse.setAttribute('value', `Your response: "${appState.gameData.turn2.response}"`);
                feedbackTone.setAttribute('value', `Tone: ${appState.gameData.turn2.tone}`);
                feedbackPositive.setAttribute('value', '✓ You helped de-escalate the situation');
                feedbackSuggestion.setAttribute('value', 'Keep using calm, clear communication');
                feedbackBetterLine.setAttribute('value', 'Try: "Let\'s all take a breath and talk this through"');
            } else {
                feedbackResponse.setAttribute('value', `Your response: "${appState.gameData.turn2.response}"`);
                feedbackTone.setAttribute('value', `Tone: ${appState.gameData.turn2.tone}`);
                feedbackPositive.setAttribute('value', '✓ You attempted to intervene safely');
                feedbackSuggestion.setAttribute('value', 'Avoid aggressive language; stay calm under pressure');
                feedbackBetterLine.setAttribute('value', 'Try: "I understand you\'re upset, but let\'s stay calm"');
            }
            
            // Show and animate the feedback card
            feedbackCard.setAttribute('visible', true);
            feedbackCard.setAttribute('scale', '1 1 1');
        }

        // Export feedback card as PNG
        function exportFeedbackCard() {
            // Clear canvas
            ctx.fillStyle = '#222222';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Add title
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Bystander Coach - Feedback Card', exportCanvas.width / 2, 50);
            
            // Add response
            ctx.fillStyle = '#FF9800';
            ctx.font = '20px Arial';
            wrapText(ctx, feedbackResponse.getAttribute('value'), exportCanvas.width / 2, 120, 700, 24);
            
            // Add tone
            ctx.fillStyle = '#4CAF50';
            ctx.font = '20px Arial';
            ctx.fillText(feedbackTone.getAttribute('value'), exportCanvas.width / 2, 180);
            
            // Add positive feedback
            ctx.fillStyle = '#4CAF50';
            ctx.font = '20px Arial';
            wrapText(ctx, feedbackPositive.getAttribute('value'), exportCanvas.width / 2, 240, 700, 24);
            
            // Add suggestion
            ctx.fillStyle = '#FF5722';
            ctx.font = '20px Arial';
            wrapText(ctx, feedbackSuggestion.getAttribute('value'), exportCanvas.width / 2, 300, 700, 24);
            
            // Add better line
            ctx.fillStyle = '#2196F3';
            ctx.font = '20px Arial';
            wrapText(ctx, feedbackBetterLine.getAttribute('value'), exportCanvas.width / 2, 360, 700, 24);
            
            // Add watermark
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '14px Arial';
            ctx.fillText('Bystander Coach VR Training', exportCanvas.width / 2, exportCanvas.height - 30);
            
            // Create download link
            const link = document.createElement('a');
            link.download = 'bystander-coach-feedback.png';
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        // Helper function to wrap text on canvas
        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let testLine = '';
            let lineCount = 0;
            
            for (let i = 0; i < words.length; i++) {
                testLine = line + words[i] + ' ';
                const metrics = context.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && i > 0) {
                    context.fillText(line, x, y);
                    line = words[i] + ' ';
                    y += lineHeight;
                    lineCount++;
                } else {
                    line = testLine;
                }
            }
            
            context.fillText(line, x, y);
        }

        // Reset the game to start over
        function resetGame() {
            // Reset game state
            appState.currentTurn = 1;
            appState.gameData = {
                turn1: { response: "", tone: "", branch: "" },
                turn2: { response: "", tone: "", branch: "" }
            };
            
            // Hide feedback card
            feedbackCard.setAttribute('visible', false);
            feedbackCard.setAttribute('scale', '0 0 0');
            
            // Start over with turn 1
            startTurn(1);
        }
    </script>
</body>
</html>
