<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bystander Coach — VR De-Escalation (Enhanced NPC)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    html, body { margin:0; height:100%; background:#070a10; }
    .hud {
      position:fixed; left:12px; bottom:12px; z-index:9;
      font:13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:#cbd5e1; background:rgba(9,13,22,.7); border:1px solid #1f2937;
      padding:8px 10px; border-radius:8px; max-width:460px;
    }
    .topright { position:fixed; right:12px; top:12px; z-index:9; display:flex; gap:8px; flex-wrap:wrap; }
    .btn2d { font:13px/1 system-ui; color:#e5e7eb; background:#101826; border:1px solid #334155; border-radius:8px; padding:8px 10px; cursor:pointer; }
    .btn2d:active { transform:translateY(1px); }
  </style>
</head>
<body>
  <div class="hud">
    <b>How to use</b>: Quest—point with controller ray & pull trigger. Desktop—drag to look, WASD to move.<br>
    <b>Mic</b>: click <em>Enable Mic</em>, then <em>Speak Now</em> (1s) or just use buttons.<br>
    Goal: keep calm, short, behavior-focused. Avoid labels/insults.
  </div>
  <div class="topright">
    <button id="micBtn" class="btn2d">Enable Mic</button>
    <button id="speakBtn" class="btn2d" disabled>Speak Now (1s)</button>
  </div>

  <a-scene
    renderer="antialias:true; colorManagement:true;"
    background="color:#0b0f17"
    webxr="optionalFeatures: local-floor;"
    vr-mode-ui="enabled:true"
    device-orientation-permission-ui="enabled:true"
  >
    <!-- Rig + gaze cursor + controller rays -->
    <a-entity id="rig" position="0 1.6 2.2">
      <a-entity camera look-controls wasd-controls="acceleration: 10">
        <a-entity cursor="fuse:false" position="0 0 -1"
                  geometry="primitive:ring; radiusInner:0.01; radiusOuter:0.015"
                  material="color:#e2e8f0; shader:flat; opacity:.85"></a-entity>
      </a-entity>
      <a-entity id="rightHand" laser-controls="hand:right" raycaster="objects:.clickable; far:8;"></a-entity>
      <a-entity id="leftHand"  laser-controls="hand:left"  raycaster="objects:.clickable; far:8;"></a-entity>
    </a-entity>

    <!-- Lighting & ground -->
    <a-entity light="type:hemisphere; color:#fff; groundColor:#223; intensity:1.0"></a-entity>
    <a-entity geometry="primitive:plane; width:30; height:30" rotation="-90 0 0" material="color:#0c1220; roughness:1"></a-entity>

    <!-- Minimal “bus” props -->
    <a-box position="-0.9 0.45 -1.2" depth="0.4" height="0.4" width="1.4" color="#263244"></a-box>
    <a-box position=" 0.9 0.45 -1.2" depth="0.4" height="0.4" width="1.4" color="#263244"></a-box>
    <a-cylinder position="-0.45 1.4 -1.2" radius="0.03" height="1.2" color="#2a364c"></a-cylinder>
    <a-cylinder position=" 0.45 1.4 -1.2" radius="0.03" height="1.2" color="#2a364c"></a-cylinder>

    <!-- NPC with emotions (eyes track, idle breathing, gestures, mouth anim) -->
    <a-entity id="npc" position="0 1.6 -1.6">
      <!-- Head -->
      <a-sphere id="head" radius="0.16" color="#f8c8b0" position="0 0.24 0"></a-sphere>
      <!-- Eyes -->
      <a-sphere id="eyeL" radius="0.02" color="#111" position="-0.05 0.26 0.13"></a-sphere>
      <a-sphere id="eyeR" radius="0.02" color="#111" position=" 0.05 0.26 0.13"></a-sphere>
      <!-- Brows (mood anim) -->
      <a-box id="browL" depth="0.01" height="0.01" width="0.07" color="#3b3b3b" position="-0.05 0.30 0.12"></a-box>
      <a-box id="browR" depth="0.01" height="0.01" width="0.07" color="#3b3b3b" position=" 0.05 0.30 0.12"></a-box>
      <!-- Mouth -->
      <a-box id="mouth" depth="0.02" height="0.02" width="0.10" color="#b23434" position="0 0.19 0.12"></a-box>
      <!-- Torso -->
      <a-cylinder id="torso" radius="0.18" height="0.42" color="#314155" position="0 -0.08 0"></a-cylinder>
      <!-- Arms -->
      <a-box id="armL" width="0.08" height="0.22" depth="0.08" color="#3a5068" position="-0.22 0.02 0"></a-box>
      <a-box id="armR" width="0.08" height="0.22" depth="0.08" color="#3a5068" position=" 0.22 0.02 0"></a-box>
    </a-entity>

    <!-- Hover dot -->
    <a-entity id="hoverDot" geometry="primitive:sphere; radius:0.01" material="color:#93c5fd" visible="false"></a-entity>

    <!-- Subtitle + dynamic options panel -->
    <a-entity id="panel" geometry="primitive:plane; width:1.35; height:0.86"
              position="0 1.15 -1.05" material="color:#071426; opacity:.92; side:double">
      <a-entity id="subtitle" position="-0.64 0.30 0"
                text="value: ; color:#e7edf7; width:1.25; wrapCount:38; align:left"></a-entity>
      <a-entity id="youSaid"  position="-0.64 0.15 0"
                text="value: ; color:#9fb6d1; width:1.25; wrapCount:38; align:left"></a-entity>

      <!-- Options container: we will re-label and re-purpose per round -->
      <a-entity id="opt1" class="clickable"
                geometry="primitive:plane; width:1.25; height:0.12"
                position="0 -0.02 0" material="color:#0d203a">
        <a-entity id="opt1text" position="-0.60 0 0"
          text="value: ; color:#e5efff; width:1.15; wrapCount:36; align:left"></a-entity>
      </a-entity>
      <a-entity id="opt2" class="clickable"
                geometry="primitive:plane; width:1.25; height:0.12"
                position="0 -0.20 0" material="color:#0c1b31">
        <a-entity id="opt2text" position="-0.60 0 0"
          text="value: ; color:#dbeafe; width:1.15; wrapCount:36; align:left"></a-entity>
      </a-entity>
      <a-entity id="opt3" class="clickable"
                geometry="primitive:plane; width:1.25; height:0.12"
                position="0 -0.38 0" material="color:#0a1627">
        <a-entity id="opt3text" position="-0.60 0 0"
          text="value: ; color:#c7d2fe; width:1.15; wrapCount:36; align:left"></a-entity>
      </a-entity>
    </a-entity>

    <!-- Feedback Card -->
    <a-entity id="card" visible="false"
              geometry="primitive:plane; width:1.35; height:0.86"
              position="0 1.15 -1.05" material="color:#00152b; opacity:.98; side:double">
      <a-entity id="cardTitle" position="-0.64 0.30 0"
                text="value: ; color:#a7f3d0; width:1.25; wrapCount:38; align:left"></a-entity>
      <a-entity id="cardBody"  position="-0.64 0.10 0"
                text="value: ; color:#e7edf7; width:1.25; wrapCount:38; align:left"></a-entity>
      <a-entity id="btnSave" class="clickable"
                geometry="primitive:plane; width:0.56; height:0.12"
                position="-0.30 -0.30 0" material="color:#0f2d4a">
        <a-entity text="value: Save Card (PNG); color:#e0f2fe; width:0.5; align:center"></a-entity>
      </a-entity>
      <a-entity id="btnReplay" class="clickable"
                geometry="primitive:plane; width:0.56; height:0.12"
                position="0.30 -0.30 0" material="color:#0b2b33">
        <a-entity text="value: Replay; color:#d1fae5; width:0.5; align:center"></a-entity>
      </a-entity>
    </a-entity>

    <!-- Logic -->
    <script>
    // ---------- Scenario with CHANGING options per round ----------
    const SCENARIO = {
      id: 'bus_enhanced',
      rounds: [
        {
          name: 'Round 1 — Set a boundary',
          npc_line: "Hey. Why are you sitting there? Move. Now.",
          options: [
            {label:"Direct: “That’s not okay. Please stop.”",   tag:"DIRECT",  good:["that's not okay","please stop","not okay","stop"], bad:["idiot","shut up"]},
            {label:"Distract: “Hey, is this seat free?”",       tag:"DISTRACT",good:["seat free","is this seat"],                            bad:[]},
            {label:"Check-in: “Are you okay?”",                 tag:"CHECKIN", good:["are you okay","you okay"],                             bad:[]}
          ],
          branches: { STRONG:{react:"…Whatever. I’m just saying.", outcome:"cooling"},
                      NEUTRAL:{react:"Huh? Mind your business.",   outcome:"stall"},
                      ESCALATE:{react:"Oh really? You wanna go?",  outcome:"escalate"} }
        },
        {
          name: 'Round 2 — Hold your ground',
          npc_line: "Tch. Why do you care?",
          options: [
            {label:"Direct (short): “Everyone deserves respect.”", tag:"DIRECT",  good:["respect","deserves respect"], bad:["stupid","loser"]},
            {label:"Delegate: “Driver, can you help here?”",       tag:"DELEGATE",good:["driver","help here"],                              bad:[]},
            {label:"De-escalate: “We’re just riding. Let them be.”",tag:"DEESC",  good:["let them be","we're just riding"],                 bad:[]}
          ],
          branches: { STRONG:{react:"Fine.",       outcome:"cooling"},
                      NEUTRAL:{react:"Whatever.",  outcome:"stall"},
                      ESCALATE:{react:"Back off!", outcome:"escalate"} }
        },
        {
          name: 'Round 3 — Exit or support',
          npc_line: "Whatever…",
          options: [
            {label:"Support Target: “We’re here. Need a seat?”",  tag:"SUPPORT", good:["need a seat","we're here"], bad:[]},
            {label:"Move Group: “Let’s sit over there.”",         tag:"MOVE",    good:["sit over there","over there"], bad:[]},
            {label:"Light Reset: “Let’s give space.”",            tag:"RESET",   good:["give space"], bad:[]}
          ],
          branches: { STRONG:{react:"…Okay.", outcome:"cooling"},
                      NEUTRAL:{react:"Tch.",  outcome:"stall"},
                      ESCALATE:{react:"Tss.", outcome:"escalate"} }
        },
        {
          name: 'Delay — Check on the target',
          npc_line: "(The aggressor is quiet. Check on the person.)",
          options: [
            {label:"“Are you alright?”", tag:"AFTERCARE", good:["are you alright","are you okay"], bad:[]},
            {label:"“Do you want me to stay?”", tag:"AFTERCARE", good:["stay"], bad:[]},
            {label:"“Want to move seats?”", tag:"AFTERCARE", good:["move seats"], bad:[]}
          ],
          branches: { STRONG:{react:"Thanks.", outcome:"cooling"},
                      NEUTRAL:{react:"Okay.",  outcome:"cooling"},
                      ESCALATE:{react:"—",     outcome:"cooling"} }
        }
      ],
      tips: [
        "One short sentence > long arguments.",
        "Address behavior, not identity.",
        "Keep volume steady; avoid insults.",
        "If unsafe, prioritize Delegating or Moving."
      ]
    };

    // ---------- State ----------
    const S = {
      round: 0,
      mood: 0,              // -3 (hostile) … +3 (calm)
      lastTone: 'ASSERTIVE',
      lastSpeech: '',
      path: []
    };

    // ---------- A-Frame refs ----------
    const $ = s => document.querySelector(s);
    const af = s => document.querySelector(s);
    const subtitle = af('#subtitle');
    const youSaid  = af('#youSaid');

    // Facial parts
    const head = af('#head'), browL = af('#browL'), browR = af('#browR'), mouth = af('#mouth');
    const eyeL = af('#eyeL'), eyeR = af('#eyeR'), armL = af('#armL'), armR = af('#armR');

    // ---------- NPC idle / emotion visuals ----------
    function applyMoodVisual(mood){
      // Brows: angry = slanted down; calm = flat / raised a bit
      const tilt = THREE.MathUtils.clamp(mood, -3, 3) * -0.15; // negative tilts down towards center
      browL.object3D.rotation.z = tilt;
      browR.object3D.rotation.z = -tilt;

      // Mouth: angry = wider + thinner; calm = small smile
      const w = THREE.MathUtils.mapLinear(mood, -3, 3, 0.14, 0.08);
      const h = THREE.MathUtils.mapLinear(mood, -3, 3, 0.015, 0.03);
      mouth.setAttribute('geometry', `primitive: box; width:${w.toFixed(3)}; height:${h.toFixed(3)}; depth:0.02`);
      mouth.setAttribute('material', `color:${mood<=-1? '#b23434' : mood>=2? '#4ade80' : '#d97706'}`);

      // Arms: angry = lifted; calm = lowered
      armL.object3D.position.y = THREE.MathUtils.mapLinear(mood, -3, 3, 0.12, -0.02);
      armR.object3D.position.y = THREE.MathUtils.mapLinear(mood, -3, 3, 0.12, -0.02);

      // Head tiny nod/no-nod in response will be added in react()
    }

    // Eyes track camera a bit
    function trackEyes(){
      const cam = document.querySelector('[camera]').object3D;
      const npc = $('#npc').object3D;
      const targetWorld = new THREE.Vector3();
      cam.getWorldPosition(targetWorld);
      const local = npc.worldToLocal(targetWorld.clone());
      const clamp = v => THREE.MathUtils.clamp(v, -0.04, 0.04);
      eyeL.object3D.position.x = -0.05 + clamp(local.x*0.02);
      eyeR.object3D.position.x =  0.05 + clamp(local.x*0.02);
      eyeL.object3D.position.y =  0.26 + clamp(local.y*0.01);
      eyeR.object3D.position.y =  0.26 + clamp(local.y*0.01);
    }
    setInterval(trackEyes, 120);

    // Idle breathing
    head.setAttribute('animation__breath', 'property: position; to: 0 0.245 0; dir: alternate; dur: 1800; loop: true; easing: easeInOutSine');
    af('#torso').setAttribute('animation__breath', 'property: position; to: 0 -0.075 0; dir: alternate; dur: 1800; loop: true; easing: easeInOutSine');

    // Mouth talk wiggle
    function npcTalk(ms=1100){
      mouth.setAttribute('animation__talk', 'property: position; to: 0 0.205 0.13; dir: alternate; dur: 120; loop: 8; easing: easeInOutSine');
      setTimeout(()=> mouth.removeAttribute('animation__talk'), ms);
    }

    // React gesture
    function reactGesture(kind){
      if (kind==='ESCALATE'){
        // head jerk + arm lift
        head.setAttribute('animation__jerk', 'property: rotation; to: 0 0.12 0; dir: alternate; dur: 120; loop: 3; easing: easeOutQuad');
        armR.setAttribute('animation__lift', 'property: position; to: 0.22 0.16 0; dir: alternate; dur: 180; loop: 2; easing: easeOutQuad');
        setTimeout(()=>{ head.removeAttribute('animation__jerk'); armR.removeAttribute('animation__lift'); }, 900);
      } else if (kind==='STRONG'){
        // small nod
        head.setAttribute('animation__nod', 'property: rotation; to: -0.08 0 0; dir: alternate; dur: 140; loop: 3; easing: easeInOutQuad');
        setTimeout(()=> head.removeAttribute('animation__nod'), 850);
      }
    }

    // ---------- Mic / tone ----------
    const Mic = { stream:null, ctx:null, analyser:null, buf:null };
    async function enableMic(){
      if (Mic.stream) return true;
      try{
        const stream = await navigator.mediaDevices.getUserMedia({audio:true});
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const src = ctx.createMediaStreamSource(stream);
        const analyser = ctx.createAnalyser(); analyser.fftSize = 2048;
        src.connect(analyser);
        Mic.stream = stream; Mic.ctx = ctx; Mic.analyser = analyser; Mic.buf = new Float32Array(analyser.fftSize);
        document.getElementById('speakBtn').disabled = false;
        return true;
      }catch(e){ alert('Mic denied. You can still use buttons.'); return false; }
    }
    function measureTone(ms=1000){
      return new Promise(res=>{
        const {analyser, buf} = Mic; let frames=0, sumAbs=0, pace=0, prev=0; const t0=performance.now();
        (function loop(){
          analyser.getFloatTimeDomainData(buf);
          let abs=0; for (let i=0;i<buf.length;i++){ const v=buf[i]; abs += Math.abs(v); pace += Math.abs(v-prev); prev=v; }
          sumAbs += abs/buf.length; frames++;
          if (performance.now()-t0 < ms) requestAnimationFrame(loop);
          else {
            const rms = (sumAbs/frames)||0; const paceNorm = pace/(frames*buf.length);
            let bucket='CALM'; if (rms>0.6 || paceNorm>0.008) bucket='AGGRESSIVE'; else if (rms>=0.25) bucket='ASSERTIVE';
            res({rms:+rms.toFixed(3), pace:+paceNorm.toFixed(4), bucket});
          }
        })();
      });
    }

    // ---------- Scoring ----------
    function score(turn, text, tone){
      const t = (text||'').toLowerCase();
      const hasGood = turn.options.some(o => o.good.some(k=> t.includes(k)));
      const hasBad  = turn.options.some(o => o.bad.some(k=> t.includes(k)));
      if (hasGood && tone!=='AGGRESSIVE') return 'STRONG';
      if (hasBad  || tone==='AGGRESSIVE') return 'ESCALATE';
      return 'NEUTRAL';
    }

    function adjustMood(branchKey){
      if (branchKey==='STRONG') S.mood = Math.min(3, S.mood+1);
      if (branchKey==='ESCALATE') S.mood = Math.max(-3, S.mood-1);
      // NEUTRAL keeps mood
      applyMoodVisual(S.mood);
    }

    // ---------- UI helpers ----------
    function setSubtitle(v){ subtitle.setAttribute('text','value',v); npcTalk(); }
    function setYou(v){ youSaid.setAttribute('text','value', v? `You: ${v}` : ''); }

    function labelOptions(round){
      const [o1,o2,o3] = round.options;
      af('#opt1text').setAttribute('text','value', o1.label);
      af('#opt2text').setAttribute('text','value', o2.label);
      af('#opt3text').setAttribute('text','value', o3.label);
    }

    // ---------- Flow ----------
    function showRound(){
      const round = SCENARIO.rounds[S.round];
      setSubtitle(`${round.name}\n${round.npc_line}`);
      setYou('');
      labelOptions(round);
    }

    function applyResponse(text, chosenTag){
      const round = SCENARIO.rounds[S.round];
      const tone = Mic.stream ? S.lastTone : 'ASSERTIVE';
      const branchKey = score(round, text || chosenTag || '', tone);
      const react = round.branches[branchKey];
      setYou(text ? `${text}  (${tone})` : `${chosenTag}  (${tone})`);
      reactGesture(branchKey);
      setSubtitle(react.react);
      S.path.push({ round:S.round, branch:branchKey, outcome:react.outcome, tone, text:text||chosenTag||'' });
      adjustMood(branchKey);

      // progress timing depends on mood: calmer → faster move on
      const wait = 900 + (S.mood<0 ? 400 : 0);
      setTimeout(()=>{
        if (S.round >= SCENARIO.rounds.length-1) endGame();
        else { S.round++; showRound(); }
      }, wait);
    }

    function endGame(){
      const win = S.path.some(p=>p.outcome==='cooling');
      const title = win ? '✅ You cooled it down.' : '⚠️ Let’s improve that boundary.';
      const good  = win ? 'What worked:\n• Short, clear boundary.\n• No labels/insults.\n• Steady tone.\n' :
                          'Try this:\n• One sentence boundary.\n• Address behavior, not identity.\n• Lower volume; slow pace.\n';
      const better = '“That’s not okay. Please stop.”  “We’re just riding; let them be.”';

      af('#panel').setAttribute('visible','false');
      af('#card').setAttribute('visible','true');
      af('#cardTitle').setAttribute('text','value', title);
      const last = S.path[S.path.length-1] || {};
      af('#cardBody').setAttribute('text','value',
        `Last response: “${last.text||'—'}”\nTone: ${last.tone||S.lastTone}\n\n${good}\nBetter lines:\n${better}`);

      uiBeep(true);
    }

    function resetAll(){
      S.round = 0; S.mood = 0; S.lastTone='ASSERTIVE'; S.lastSpeech=''; S.path=[];
      applyMoodVisual(S.mood);
      af('#card').setAttribute('visible','false');
      af('#panel').setAttribute('visible','true');
      showRound();
    }

    // ---------- Click binding & hover dot ----------
    function bindClickable(el, handler){
      el.addEventListener('click', handler);
      // hover feedback via controller rays
      ['rightHand','leftHand'].forEach(id=>{
        const rc = af('#'+id);
        rc.addEventListener('raycaster-intersection', e=>{
          const hit = e.detail.intersections?.find(i => i.object.el === el);
          if (!hit) return;
          const dot = af('#hoverDot');
          const p = hit.point; dot.object3D.position.set(p.x,p.y,p.z);
          dot.setAttribute('visible','true');
        });
        rc.addEventListener('raycaster-intersection-cleared', ()=> af('#hoverDot').setAttribute('visible','false'));
      });
    }

    // Option clicks map to CURRENT ROUND’S labels (context-aware)
    bindClickable(af('#opt1'), ()=> {
      const lbl = af('#opt1text').getAttribute('text').value;
      const tag = SCENARIO.rounds[S.round].options[0].tag;
      applyResponse(lbl, tag);
    });
    bindClickable(af('#opt2'), ()=> {
      const lbl = af('#opt2text').getAttribute('text').value;
      const tag = SCENARIO.rounds[S.round].options[1].tag;
      applyResponse(lbl, tag);
    });
    bindClickable(af('#opt3'), ()=> {
      const lbl = af('#opt3text').getAttribute('text').value;
      const tag = SCENARIO.rounds[S.round].options[2].tag;
      applyResponse(lbl, tag);
    });

    // Card buttons
    bindClickable(af('#btnReplay'), ()=> resetAll());
    bindClickable(af('#btnSave'),   ()=> exportCardPNG());

    // ---------- Mic UI ----------
    document.getElementById('micBtn').addEventListener('click', async ()=>{
      const ok = await enableMic(); if (ok) document.getElementById('micBtn').textContent='Mic Enabled';
    });
    document.getElementById('speakBtn').addEventListener('click', async ()=>{
      if (!Mic.stream) { alert('Enable Mic first or use the buttons.'); return; }
      document.getElementById('speakBtn').textContent='Listening…';
      const {bucket} = await measureTone(1000);
      S.lastTone = bucket;
      document.getElementById('speakBtn').textContent='Speak Now (1s)';
      // Optional desktop STT (Quest often lacks it)
      let text = '';
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (SR){
        text = await new Promise(resolve=>{
          const r = new SR(); r.lang='en-US'; r.interimResults=false; r.maxAlternatives=1;
          let got=false; const stopAt=Date.now()+1400;
          r.onresult = e=>{ if(got) return; got=true; resolve(e.results[0][0].transcript||''); };
          r.onerror  = ()=>{ if(!got){got=true; resolve('');} };
          r.onend    = ()=>{ if(!got){got=true; resolve('');} };
          r.start(); setTimeout(()=> r.stop(), 1200);
        });
      }
      if (!text){
        setYou(`(Voice tone: ${S.lastTone}). Pick an option or speak a short line.`);
        return;
      }
      applyResponse(text, 'VOICE');
    });

    // ---------- Save PNG ----------
    function exportCardPNG(){
      const title = af('#cardTitle').getAttribute('text').value;
      const body  = af('#cardBody').getAttribute('text').value;
      const pad=20, w=880, h=560, cnv=document.createElement('canvas'); cnv.width=w; cnv.height=h; const ctx=cnv.getContext('2d');
      ctx.fillStyle='#00152b'; ctx.fillRect(0,0,w,h);
      ctx.fillStyle='#a7f3d0'; ctx.font='bold 22px system-ui, Segoe UI, Roboto'; ctx.fillText(title, pad, pad+24);
      ctx.fillStyle='#e7edf7'; ctx.font='16px system-ui, Segoe UI, Roboto';
      wrap(ctx, body, w-pad*2).forEach((line,i)=> ctx.fillText(line, pad, pad+64 + i*22));
      const a=document.createElement('a'); a.href=cnv.toDataURL('image/png'); a.download='bystander_coach_card.png'; a.click();
    }
    function wrap(ctx, text, width){
      const words=text.split(/\s+/), lines=[]; let line='';
      for (const w of words){ const t=line? line+' '+w : w; if (ctx.measureText(t).width>width){ if(line) lines.push(line); line=w; } else line=t; }
      if (line) lines.push(line); return lines;
    }

    // Tiny audio cue
    function uiBeep(ok=true){
      const AC = window.AudioContext||window.webkitAudioContext; const ctx=new AC();
      const o=ctx.createOscillator(), g=ctx.createGain(); o.connect(g); g.connect(ctx.destination);
      o.type='sine'; o.frequency.value= ok? 960: 220; g.gain.value=0.0001; o.start();
      g.gain.exponentialRampToValueAtTime(0.02, ctx.currentTime+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.18); o.stop(ctx.currentTime+0.2);
    }

    // ---------- Start ----------
    document.addEventListener('DOMContentLoaded', ()=>{
      applyMoodVisual(S.mood);
      showRound();
    });
    </script>
  </a-scene>
</body>
</html>
